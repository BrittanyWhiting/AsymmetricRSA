#Brittany Whiting, Macie Chudy, and Kaitlin Jones#Project 1 - RSAimport randomfrom random import randrange# function to allow user choice and a termination conditiondef user_input():    choice = input("Press D for a Signature, press M to Encrypt/Decrypt a Message, press E to Exit.   ")    while (choice != "D" and choice != "M" and choice != "d" and choice != "m" and choice != "E" and choice != "e"):        print ("ERROR: Did not enter D, M, or E")        choice = input("Press D for a Signature, press M to Encrypt/Decrypt a Message, press E to Exit.   ")    if(choice == "D" or choice == "d"):        print("You chose to create a Digital Signature")    elif(choice == "M" or choice == "m"):        print("You chose to create a Message")    else:        print(" You chose to Exit the program")    return choice# Using Miller-Rabin Primality Test# referenced from chapter 1.3.1 # and created using pseudocode from https://aquarchitect.github.io/swift-algorithm-club/Miller-Rabin%20Primality%20Test/def prime_num(n, k=100):    prime_list = []    # test to see is n is negative or even    if n <= 1 or n % 2 == 0:        return False    # define counter and find d    counter = 0    d = n - 1    while d & 1 == 0:        counter += 1        d //= 2    # do k tests    for i in range(k):        a = randrange(2, n - 1)        x = pow(a, d, n)        if x != 1 and x != n - 1:            counter2 = 1            while counter2 < counter and x != n - 1:                x = pow(x, 2, n)                if x == 1:                    return False                counter2 += 1            if x != n - 1:                return False    return Truedef generate_prime_number():    #random number from 100,000 to 1,000,000    p = random.randint(10000, 1000001)    # run primality test 50 times, keep generating if primality test fails    while not prime_num(p, 100):    	print(str(p) + " is not prime")    	p = random.randint(10000, 1000001)    return p     def gcd(a, b):    while b != 0:        a, b = b, a % b    return adef mult_inverse(a, m):   u1, u2, u3 = 1, 0, a   v1, v2, v3 = 0, 1, m      while v3 != 0:      q = u3 // v3      v1, v2, v3, u1, u2, u3 = (u1 - q * v1), (u2 - q * v2), (u3 - q * v3), v1, v2, v3   return u1 % m    #using the values we found above, calculate the keys    def generate_keys(p,q):	#n = p * q	n = p * q		#f(n) = (p-1)(q-1)	fn = ((p-1) * (q-1))		#find an e that is f(n) that are co-prime	e = random.randrange(1, fn)		#use Euclid's algorithm to check that e & f(n) are co-prime	euclid = gcd(e, fn)	while euclid !=1:		e = random.randrange(1, fn)		euclid = gcd(e, fn)		#use extended algorithm to create the PRIVATE key	d = mult_inverse(e, fn)	#return the key pairs    #public = e,n and private = d	return ((n, e), (d))	def encrpyt_message(pubkey, text):	# M = M ^ e mod n	n, key = pubkey	# turn the individual letter into an int representing the unicode number for the letter	cipher_text = [pow(ord(char), key, n) for char in text]	# print("CT = ", cipher_text)	return cipher_textdef decrypt_message(privkey, cipher_text,n):	# M = C ^ d mod n	key = privkey	n = n	# reverse the ord() function above and use the chr() library to turn the number back into	# a character 	original_message = [chr(pow(char, key, n)) for char in cipher_text]# 	print("My message is : ", original_message)	return ''.join(original_message)		def encrypt_signature(privkey, signature, n):	# s = decrypt(Kd,M) using private key	# Becuase we are creating a digital key, we are using the private key to encrypt the message 	key = privkey	n = n	# turn the individual letter into an int representing the unicode number for the letter 	digital_signature = [(pow(ord(char), key, n)) for char in signature]	# print("My digital sig = ", digital_signature)	return digital_signature			def decrypt_signature(publickey, digsignature):	# ne, using public key	# Because we are creating a digital signature we use the public key to decrypt the message	n, key = publickey	# reverse the ord() function above and use the chr() library to turn the number back into	# a character 	orig_signature = [chr(pow(char, key, n)) for char in digsignature]	# print("My original sig= ", orig_signature)-------> for testing purposes	return orig_signature# Make sure that M' = M def check_signature(signature, test_signature):	signature = signature	test_signature = test_signature	if(signature == test_signature):		print("Your original signature matches your computed signature! Signature Verified!")	else:		print("Signature Error.")print("\n")print("Asymmetric RSA System")print("\nYou can either make a Digital Signature, or Encrypt / Decrypt a message!")print("\n")print("Testing to see if the number is prime: ")p = generate_prime_number()q = generate_prime_number()print("\n")print("Your P and your Q are: ")print (str(p) + " " + str(q))print("\nCreating Key Pairs")public, private = generate_keys(p, q)print("Your public key is", public)print("Your private key is", private)print("\n")n = public[0]# print(n) -----> Testing purposes#give the user a choice to create a signature or type a messagechoice = user_input()if(choice == "M" or choice == "m"):	message = input("Enter a message, (this will be encrypted with the public key): ")	encrypted_message = encrpyt_message(public,message)	print("Your encrypted message is: ")	print(''.join(map(lambda x: str(x), encrypted_message)))# 	print(encrypted_message)--------> this was for testing purposes	print("\nNow we will decrypt the message with the public key. ")	print ("Your original message is: ", decrypt_message(private,encrypted_message,n))if(choice == "D" or choice == "d"):	signature = input("Enter your Signature: ")	#using the private key above decrypt the signature	digitial_signature = encrypt_signature(private, signature, n)	print("Your signature key-pair is: ", signature, ",", ''.join(map(lambda x: str(x), digitial_signature)))	print("\nNow we use the public key to check if the signature key is equal to original signature.")	test_signature = decrypt_signature(public, digitial_signature)	test_signature = (''.join(map(lambda x: str(x), test_signature)))	check_signature(signature, test_signature)	